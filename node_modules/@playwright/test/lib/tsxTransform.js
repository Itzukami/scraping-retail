"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@babel/core");

var _helperPluginUtils = require("@babel/helper-plugin-utils");

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return {
    name: 'playwright-debug-transform',
    visitor: {
      Program(path) {
        path.setData('pw-components', new Map());
      },

      ImportDeclaration(path) {
        // Non-JSX transform, replace
        //   import Button from './ButtonVue.vue'
        //   import { Card as MyCard } from './Card.vue'
        // with
        //   const Button 'Button', MyCard = 'Card';
        const importNode = path.node;

        if (!_core.types.isStringLiteral(importNode.source)) {
          flushConst(path, true);
          return;
        }

        if (!importNode.source.value.endsWith('.vue') && !importNode.source.value.endsWith('.svelte')) {
          flushConst(path, true);
          return;
        }

        const components = path.parentPath.getData('pw-components');

        for (const specifier of importNode.specifiers) {
          if (_core.types.isImportDefaultSpecifier(specifier)) {
            components.set(specifier.local.name, specifier.local.name);
            continue;
          }

          if (_core.types.isImportSpecifier(specifier)) {
            if (_core.types.isIdentifier(specifier.imported)) components.set(specifier.local.name, specifier.imported.name);else components.set(specifier.local.name, specifier.imported.value);
          }
        }

        flushConst(path, false);
      },

      JSXElement(path) {
        const jsxElement = path.node;
        const jsxName = jsxElement.openingElement.name;
        if (!_core.types.isJSXIdentifier(jsxName)) return;
        const name = jsxName.name;
        const props = [];

        for (const jsxAttribute of jsxElement.openingElement.attributes) {
          if (_core.types.isJSXAttribute(jsxAttribute)) {
            let namespace;
            let name;

            if (_core.types.isJSXNamespacedName(jsxAttribute.name)) {
              namespace = jsxAttribute.name.namespace;
              name = jsxAttribute.name.name;
            } else if (_core.types.isJSXIdentifier(jsxAttribute.name)) {
              name = jsxAttribute.name;
            }

            if (!name) continue;
            const attrName = (namespace ? namespace.name + ':' : '') + name.name;
            if (_core.types.isStringLiteral(jsxAttribute.value)) props.push(_core.types.objectProperty(_core.types.stringLiteral(attrName), jsxAttribute.value));else if (_core.types.isJSXExpressionContainer(jsxAttribute.value) && _core.types.isExpression(jsxAttribute.value.expression)) props.push(_core.types.objectProperty(_core.types.stringLiteral(attrName), jsxAttribute.value.expression));else props.push(_core.types.objectProperty(_core.types.stringLiteral(attrName), _core.types.nullLiteral()));
          } else if (_core.types.isJSXSpreadAttribute(jsxAttribute)) {
            props.push(_core.types.spreadElement(jsxAttribute.argument));
          }
        }

        const children = [];

        for (const child of jsxElement.children) {
          if (_core.types.isJSXText(child)) children.push(_core.types.stringLiteral(child.value));else if (_core.types.isJSXElement(child)) children.push(child);else if (_core.types.isJSXExpressionContainer(child) && !_core.types.isJSXEmptyExpression(child.expression)) children.push(child.expression);else if (_core.types.isJSXSpreadChild(child)) children.push(_core.types.spreadElement(child.expression));
        }

        path.replaceWith(_core.types.objectExpression([_core.types.objectProperty(_core.types.identifier('kind'), _core.types.stringLiteral('jsx')), _core.types.objectProperty(_core.types.identifier('type'), _core.types.stringLiteral(name)), _core.types.objectProperty(_core.types.identifier('props'), _core.types.objectExpression(props)), _core.types.objectProperty(_core.types.identifier('children'), _core.types.arrayExpression(children))]));
      }

    }
  };
});

exports.default = _default;

function flushConst(importPath, keepPath) {
  const importNode = importPath.node;
  const importNodes = importPath.parentPath.node.body.filter(i => _core.types.isImportDeclaration(i));
  const isLast = importNodes.indexOf(importNode) === importNodes.length - 1;

  if (!isLast) {
    if (!keepPath) importPath.remove();
    return;
  }

  const components = importPath.parentPath.getData('pw-components');
  if (!components.size) return;
  const variables = [];

  for (const [key, value] of components) variables.push(_core.types.variableDeclarator(_core.types.identifier(key), _core.types.stringLiteral(value)));

  importPath.skip();
  if (keepPath) importPath.replaceWithMultiple([importNode, _core.types.variableDeclaration('const', variables)]);else importPath.replaceWith(_core.types.variableDeclaration('const', variables));
}